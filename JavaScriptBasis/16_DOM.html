<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>DOM操作</title>
</head>
<body>
  <div id="div1">我是div1</div>
  <div class="div2">我是div2</div>
  <p>我是p标签</p>
  <script>
    /*
      HTML DOM(文档对象模型)：
        当网页被加载时，浏览器会创建页面的文档对象模型
        HTML DOM定义了用于HTML的一系列标准的对象，以及访问和处理HTML文档的标准方法
        通过DOM，你可以访问所有的HTML元素，连同他们所包含的文本和属性
        HTML DOM独立于平台和编程语言。
    */
    /*
      通过可编程的对象模型，JavaScript获得了足够的能力来创建动态的HTML：
        JavaScript能够改变页面中的所有HTML元素
        JavaScript能够改变页面中的所有HTML属性
        JavaScript能够改变页面中的所有CSS样式
        JavaScript能够对页面中所有事件做出反应
    */
    /*
      通常。通过JavaScript，可以操作HTML元素
        通过id找到HTML元素
          如果找到该元素，则该方法将以对象的形式返回该元素，如果没有找到，则返回null
        通过标签名找到HTML元素
        通过类名找到HTML元素
          通过标签名和类型去寻找到，找到后返回的是一个类数组，要通过下标等才能取到对应的具体元素，如果找不到返回的是undefined
    */
    var oDiv1=document.getElementById("div1");
    var aDiv2=document.getElementsByClassName("div2");
    var p=document.getElementsByTagName("p");
    console.log(oDiv1,"通过id获取元素")
    console.log(aDiv2[0],"通过class获取元素")
    console.log(p[0],"通过标签获取元素")
    /*
      javascript获取节点：
        节点指针：
          firstChild 语法 父节点.firstChild  用于获取元素的首个子节点
          lastChild  语法 父节点.lastChild   用于获取元素的最后一个节点
          childNodes 语法 父节点.childNodes  获取元素的子节点列表
          previousSibling  语法 兄弟节点.previousSibling  获取已知节点的前一个节点
          nextSibling      语法 兄弟节点.nextSibling      获取已知节点的后一个节点
          parentNode       语法  子节点.parentNode        获取已知节点的父节点
    */
    /*
      节点操作：
        创建节点：
          createElement 语法：document.createElement  创建元素节点
          createAttribute   语法： document.createAttribute  创建属性节点
          createTextNode    语法： document.createTextNode   创建文本节点
        插入节点：
          appendChild   语法：appendChild(所添加的新节点)  向节点的子节点列表的末尾添加新的子节点
          insertBefore  语法：insertBefore（所要添加的节点，已知子节点）  在已知的子节点之前插入一个新的子节点
        替换节点：
          replaceChild  语法：replaceChild（要插入的新元素，被替换的老元素） 将某个子节点替换为另一个
        复制节点：
          cloneNode     语法：需要被复制的节点.cloneNode(true/false)  创建指定节点的副本   true(复制当前节点及其所有子节点)  false(仅复制当前节点)
        删除节点：
          removeChild   语法：removeChild(要删除的节点)  删除指定的节点
    */
    /*
      属性操作：
        获取属性：getAttribute  元素节点.getAttribute(属性名)  获取元素节点中指定属性的属性值
        设置属性：setAttribute  元素节点.setAttribute(属性名，属性值)  创建或改变员孙节点的属性
        删除属性：removeAttribute   元素节点.removeAttribute(属性名)  删除元素中的指定属性
    */
    /*
      文本操作：
        insertData(offset,String) 从offset指定的位置插入string
        appendData(string)        将string插入到文本节点的末尾处
        deleteData(offset,count)  从offset起删除count个字符
        replaceData(off,count,string) 从off处将count个字符用string替代
        splitData（offset）            从offset起将文本节点分成两个子节点
        substring(offset,count)       返回由offset起的count个节点
    */
    /*
      改变html输出流：
        document.write("内容") 可以直接向HTML输出流写内容，但绝对不要在文档加载完成后使用document.write();这会覆盖该文档
      改变HTML内容：
        document.getElementById('div1').innerHTML="新的内容"，innerHTML就是用来改变标签之间的内容
      改变HTML属性：
        document.getElementById("div1").attribute="新的属性值"
      改变CSS：
        document.getElementsByClassName("div2").style.样式名(color/fontsize/visibility等)="red/14px/true/false"
    */
    /*
      HTML DOM事件：
        HTML DOM使JavaScript有能力对HTML事件作出反应
          onclick		元素上发生鼠标点击时触发。
          ondblclick		元素上发生鼠标双击时触发。
          ondrag		元素被拖动时运行的脚本。
          ondragend		在拖动操作末端运行的脚本。
          ondragenter		当元素元素已被拖动到有效拖放区域时运行的脚本。
          ondragleave		当元素离开有效拖放目标时运行的脚本。
          ondragover		当元素在有效拖放目标上正在被拖动时运行的脚本。
          ondragstart		在拖动操作开端运行的脚本。
          ondrop		当被拖元素正在被拖放时运行的脚本。
          onmousedown		当元素上按下鼠标按钮时触发。
          onmousemove		当鼠标指针移动到元素上时触发。
          onmouseout		当鼠标指针移出元素时触发。
          onmouseover		当鼠标指针移动到元素上时触发。
          onmouseup		当在元素上释放鼠标按钮时触发。
          onmousewheel		当鼠标滚轮正在被滚动时运行的脚本。
          onscroll		当元素滚动条被滚动时运行的脚本。
    */
    /*
      javascript HTML DOM EventListener
        addEventListener()方法：  
          用于向指定元素增加事件句柄
          添加的事件句柄不呼呼覆盖已经存在的事件句柄
          可以向一个元素中增加多个事件句柄
          可以向同个元素增加多个同类型的事件句柄
          可以向任何DOM对象增加事件监听
          addEventListener()方法可以更加简单的控制事件（冒泡与捕获）
          可以使用removeEventListenner来移除事件的监听

        例如：
          element.addEventListener(event,function,useCapture)
            第一个参数为事件名称 click，记住不要用on
            第二个参数为发生该事件所执行的函数 showDate
            第三个参数表示冒泡还是捕获   true 表示捕获  false表示冒泡
      向同一个元素增加多个事件柄：
        element.addEventListener("click",showData)
        element.addEventListener("click",showOther)
      向同一个元素增加不同的类型的事件
        element.addEventListener("mouseover", myFunction);
        element.addEventListener("click", mySecondFunction);
        element.addEventListener("mouseout", myThirdFunction);
      向window对象添加事件句柄：
        window.addEventListener("resize",function(){
          console.log("重置窗口大小触发这个函数")
        })
      传递参数：
        当传递参数值时，使用“匿名函数调用带参数的函数”
        element.addEventListener("click", function(){ myFunction(p1, p2); });
    */
    /*
        事件冒泡或捕获：
          事件传递有两种方式：冒泡和捕获
          事件传递定义了元素事件触发的顺序
            在冒泡中，内部元素的事件会先被触发，然后再触发外部元素
            在捕获中，外部元素的事件会先被触发，然后才会触发内部元素的事件
        提示：DOM事件流同时支持两种事件模型：捕获型事件和冒泡型事件，捕获型事件首先发生。捕获型事件和冒泡型事件会触及DOM中的所有对象，从document对象开始，也在document对象结束。
    */
  </script>
</body>
</html>